package wci.backend.compilerllvm;

import java.io.*;
import org.bytedeco.javacpp.BytePointer;

import org.bytedeco.llvm.LLVM.LLVMBuilderRef;
import org.bytedeco.llvm.LLVM.LLVMContextRef;
import org.bytedeco.llvm.LLVM.LLVMModuleRef;
import static org.bytedeco.llvm.global.LLVM.LLVMContextCreate;
import static org.bytedeco.llvm.global.LLVM.LLVMContextDispose;
import static org.bytedeco.llvm.global.LLVM.LLVMCreateBuilderInContext;
import static org.bytedeco.llvm.global.LLVM.LLVMDisposeBuilder;
import static org.bytedeco.llvm.global.LLVM.LLVMDisposeModule;
import static org.bytedeco.llvm.global.LLVM.LLVMInitializeNativeAsmParser;
import static org.bytedeco.llvm.global.LLVM.LLVMInitializeNativeAsmPrinter;
import static org.bytedeco.llvm.global.LLVM.LLVMInitializeNativeDisassembler;
import static org.bytedeco.llvm.global.LLVM.LLVMInitializeNativeTarget;
import static org.bytedeco.llvm.global.LLVM.LLVMLinkInMCJIT;
import static org.bytedeco.llvm.global.LLVM.LLVMModuleCreateWithNameInContext;
import static org.bytedeco.llvm.global.LLVM.LLVMPrintModuleToString;

import wci.backend.*;
import wci.intermediate.*;
import wci.intermediate.symtabimpl.*;
import wci.message.*;

import wci.backend.compilerllvm.generators.LlvmProgramGenerator;
import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.typeimpl.TypeFormImpl.*;
import static wci.intermediate.typeimpl.TypeKeyImpl.*;
import static wci.message.MessageType.COMPILER_SUMMARY;

/**
 *
 * @author Daniel Toffetti
 */
public class LlvmCodeGenerator extends Backend {
    
    private static PrintWriter assemblyFile;
    private static int instructionCount = 0;

    protected static SymTabEntry programId;
    protected static String programName;

    protected static LLVMContextRef context;
    protected static LLVMModuleRef module;
    protected static LLVMBuilderRef builder;
    
    protected LocalVariables localVariables;
    protected LocalStack localStack;

    /**
     * Constructor.
     */
    public LlvmCodeGenerator() {}

    /**
     * Constructor for subclasses.
     * @param parent the parent code generator.
     */
    public LlvmCodeGenerator(LlvmCodeGenerator parent) {
        super();
        this.localVariables = parent.localVariables;
        this.localStack = parent.localStack;
    }

    /**
     * Process the intermediate code and the symbol table generated by the
     * parser to generate machine-language instructions.
     * @param iCode the intermediate code.
     * @param symbolTabStack the symbol table stack.
     * @throws Exception if an error occurred.
     */
    @Override
    public void process(ICode iCode, SymTabStack symbolTabStack)
        throws Exception
    {
        symTabStack = symbolTabStack;
        long startTime = System.currentTimeMillis();

        programId = symTabStack.getProgramId();
        programName = programId.getName();
        String assemblyFileName = programName + ".ll";

        // Open a new assembly file for writing.
        assemblyFile = new PrintWriter(
                           new PrintStream(
                               new File(assemblyFileName)));

        // LLVM initializations
        LLVMLinkInMCJIT();
        LLVMInitializeNativeAsmPrinter();
        LLVMInitializeNativeAsmParser();
        LLVMInitializeNativeDisassembler();
        LLVMInitializeNativeTarget();
        // LLVM Context setup
        context = LLVMContextCreate();
        module = LLVMModuleCreateWithNameInContext(programName, context);
        builder = LLVMCreateBuilderInContext(context);

        // Generate code for the main program.
        LlvmCodeGenerator programGenerator = new LlvmProgramGenerator(this);
        programGenerator.generate(iCode.getRoot());
        // Print generated module as string into output file
        BytePointer generatedCode = LLVMPrintModuleToString(module);
        assemblyFile.print(generatedCode.getString());
        assemblyFile.close();

        // LLVM finalization
        LLVMDisposeBuilder(builder);
        LLVMDisposeModule(module);
        LLVMContextDispose(context);
        
        // Send the compiler summary message.
        float elapsedTime = (System.currentTimeMillis() - startTime)/1000f;
        sendMessage(new Message(COMPILER_SUMMARY,
                                new Number[] {instructionCount,
                                              elapsedTime}));
    }

    /**
     * Generate code for a statement.To be overridden by the code generator subclasses.
     * @param node the root node of the statement.
     * @throws wci.backend.CompilerException
     */
    public void generate(ICodeNode node) throws CompilerException {
    }

    /**
     * Generate code for a routine.To be overridden by the code generator subclasses.
     * @param routineId the routine's symbol table entry.
     * @throws wci.backend.CompilerException
     */
    public void generate(SymTabEntry routineId) throws CompilerException {
    }

//    // =========
//    // Utilities
//    // =========
//
//    /**
//     * Return whether or not a data type is structured.
//     * @param type the data type.
//     * @return true if the type is a string, array, or record; else false.
//     */
//    protected boolean isStructured(TypeSpec type)
//    {
//        TypeForm form = type.getForm();
//
//        return type.isPascalString() || (form == ARRAY) || (form == RECORD);
//    }
//
//    /**
//     * Return whether or not a variable is wrapped to pass by reference.
//     * @param variableId the symbol table entry of the variable.
//     * @return true if wrapped, false if not.
//     */
//    protected boolean isWrapped(SymTabEntry variableId)
//    {
//        TypeSpec type = variableId.getTypeSpec();
//        TypeForm form = type.getForm();
//        Definition defn = variableId.getDefinition();
//
//        // Arrays and records are not wrapped.
//        return (defn == VAR_PARM) && (form != ARRAY) && (form != RECORD);
//    }
//
//    /**
//     * Return whether or not a value needs to be cloned to pass by value.
//     * @param formalId the symbol table entry of the formal parameter.
//     * @return true if needs wrapping, false if not.
//     */
//    protected boolean needsCloning(SymTabEntry formalId)
//    {
//        TypeSpec type = formalId.getTypeSpec();
//        TypeForm form = type.getForm();
//        Definition defn = formalId.getDefinition();
//
//        // Arrays and records are normally passed by reference
//        // and so must be cloned to be passed by value.
//        return (defn == VALUE_PARM) && ((form == ARRAY) || (form == RECORD));
//    }
//
//    /**
//     * Generate a type descriptor of an identifier's type.
//     * @param id the symbol table entry of an identifier.
//     * @return the type descriptor.
//     */
//    protected String typeDescriptor(SymTabEntry id)
//    {
//        TypeSpec type = id.getTypeSpec();
//
//        if (type != null) {
//            if (isWrapped(id)) {
//                return "L" + varParmWrapper(type.baseType()) + ";";
//            }
//            else {
//                return typeDescriptor(id.getTypeSpec());
//            }
//        }
//        else {
//            return "V";
//        }
//    }
//
//    /**
//     * Generate a type descriptor for a data type.
//     * @param type the data type.
//     * @return the type descriptor.
//     */
//    protected String typeDescriptor(TypeSpec type)
//    {
//        TypeForm form = type.getForm();
//        StringBuilder buffer = new StringBuilder();
//
//        while ((form == ARRAY) && !type.isPascalString()) {
//            buffer.append("[");
//            type = (TypeSpec) type.getAttribute(ARRAY_ELEMENT_TYPE);
//            form = type.getForm();
//        }
//
//        type = type.baseType();
//
//        if (type == Predefined.integerType) {
//            buffer.append("I");
//        }
//        else if (type == Predefined.realType) {
//            buffer.append("F");
//        }
//        else if (type == Predefined.booleanType) {
//            buffer.append("Z");
//        }
//        else if (type == Predefined.charType) {
//            buffer.append("C");
//        }
//        else if (type.isPascalString()) {
//            buffer.append("Ljava/lang/StringBuilder;");
//        }
//        else if (form == ENUMERATION) {
//            buffer.append("I");
//        }
//        else /* (form == RECORD) */ {
//            buffer.append("Ljava/util/HashMap;");
//        }
//
//        return buffer.toString();
//    }
//
//    /**
//     * Generate a Java type descriptor for a data type.
//     * @param type the data type.
//     * @return the type descriptor.
//     */
//    private String javaTypeDescriptor(TypeSpec type)
//    {
//        TypeForm form = type.getForm();
//        StringBuilder buffer = new StringBuilder();
//        boolean isArray = false;
//
//        while ((form == ARRAY) && !type.isPascalString()) {
//            buffer.append("[");
//            type = (TypeSpec) type.getAttribute(ARRAY_ELEMENT_TYPE);
//            form = type.getForm();
//            isArray = true;
//        }
//
//        if (isArray) {
//            buffer.append("L");
//        }
//
//        type = type.baseType();
//
//        if (type == Predefined.integerType) {
//            buffer.append("java/lang/Integer");
//        }
//        else if (type == Predefined.realType) {
//            buffer.append("java/lang/Float");
//        }
//        else if (type == Predefined.booleanType) {
//            buffer.append("java/lang/Boolean");
//        }
//        else if (type == Predefined.charType) {
//            buffer.append("java/lang/Character");
//        }
//        else if (type.isPascalString()) {
//            buffer.append("java/lang/StringBuilder");
//        }
//        else if (form == ENUMERATION) {
//            buffer.append("java/lang/Integer");
//        }
//        else /* (form == RECORD) */ {
//            buffer.append("java/util/HashMap");
//        }
//
//        if (isArray) {
//            buffer.append(";");
//        }
//
//        return buffer.toString();
//    }
//
//    /**
//     * Return the valueOf() signature for a given scalar type.
//     * @param type the scalar type.
//     * @return the valueOf() signature.
//     */
//    protected String valueOfSignature(TypeSpec type)
//    {
//        String javaType = javaTypeDescriptor(type);
//        String typeCode = typeDescriptor(type);
//
//        return String.format("%s.valueOf(%s)L%s;",
//                             javaType, typeCode, javaType);
//    }
//
//    /**
//     * Return the xxxValue() signature for a given scalar type.
//     * @param type the scalar type.
//     * @return the valueOf() signature.
//     */
//    protected String valueSignature(TypeSpec type)
//    {
//        String javaType = javaTypeDescriptor(type);
//        String typeCode = typeDescriptor(type);
//        String typeName = type == Predefined.integerType ? "int"
//                        : type == Predefined.realType    ? "float"
//                        : type == Predefined.booleanType ? "boolean"
//                        : type == Predefined.charType    ? "char"
//                        :                                  "int";
//
//        return (String.format("%s.%sValue()%s",
//                              javaType, typeName, typeCode));
//    }
//
//    /**
//     * Generate the name of the wrapper to use to pass an actual parameter
//     * by reference.
//     * @param type the parameter type.
//     * @return the name of the wrapper.
//     */
//    protected String varParmWrapper(TypeSpec type)
//    {
//        type = type.baseType();
//
//        TypeForm form = type.getForm();
//
//        return type == Predefined.integerType ? "IWrap"
//             : type == Predefined.realType    ? "RWrap"
//             : type == Predefined.booleanType ? "BWrap"
//             : form == ENUMERATION            ? "IWrap"
//             :                                  "CWrap";
//    }

}
